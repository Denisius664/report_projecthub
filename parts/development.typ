= Подробное описание разработки проекта

== Выбор технологий и инструментов, моделей, алгоритмов

Для разработки проекта, были выбраны следующие технологии и инструменты:
+ База данных: PostgreSQL. 
 - Высокая производительность, поддержка JSONB и LTREE для хранения гибких метаданных и иерархий, открытая лицензия, наличие Docker-образа для удобного развертывания.
+ Хранилище файлов: MinIO. 
 - Совместимость с S3 API, высокая производительность по сравнению с другими открытыми продуктами, политика лицензирования, популярность, наличие Docker-образа.
+ Бэкенд: FastAPI (Python).
 - Простота изучения, минимальное число зависимостей, необходимый функционал для реализации JWT-аутентификации и авторизации, высокая производительность для построения API.
+ Фронтенд: Vue 3 (TypeScript). 
 - Относительная простота разработки по сравнению с React и Angular, подходит для небольшого проекта, богатый набор библиотек.
+ Безопасность: JWT-токены. 
 - Удобный в использовании, высокий стандарт безосопасности.
+ Инфраструктура: Docker-образы
 - Удобное развертывание на незнакомой инфраструктуре; поддержка Linux или Windows для серверов.

== Архитектура приложения (общая схема архитектуры, компоненты и уровни системы, взаимодействие между модулями, описание классов)

Система ProjectHub построена на классической клиент-серверной архитектуре с использованием REST API для взаимодействия между компонентами. Это многослойная архитектура, где клиентская часть отвечает за пользовательский интерфейс и взаимодействие с пользователем, а серверная часть обрабатывает бизнес-логику, управляет данными и обеспечивает безопасность. Данные хранятся в централизованной базе данных, а файлы проектов — в отдельном объектном хранилище. Такая архитектура позволяет обеспечить масштабируемость, отказоустойчивость и разделение ответственности между компонентами((@fig:sequence_diagram)).

#figure(
  image("../images/sequence_diagram.jpg", width: 90%),
  caption: "Взаимодействие между компанентами"
) <fig:sequence_diagram>

Основные компоненты и уровни системы:
- Клиентская часть: Реализована как веб-приложение на TypeScript с использованием фреймворка Vue 3. Обеспечивает удобный пользовательский интерфейс для регистрации, авторизации, загрузки проектов, поиска и фильтрации. Взаимодействует с сервером через REST API, отправляя запросы и получая ответы в формате JSON.
- Серверная часть: Реализована на Python с использованием FastAPI. Обрабатывает запросы от клиента, выполняет валидацию данных, управляет бизнес-логикой, контролирует права доступа пользователей и взаимодействует с базой данных и файловым хранилищем.
- База данных: PostgreSQL с использованием расширений JSONB (для хранения гибких метаданных) и LTREE (для иерархий предметных областей). Структура нормализована (3НФ), включает таблицы для пользователей, проектов, предметных областей, файлов, связей между проектами и участников.
- Объектное хранилище файлов: MinIO (совместимо с Amazon S3). Хранит оригинальные файлы проектов; в БД хранятся только ссылки (URL) и метаданные.

Взаимодействие между модулями:
- Клиент отправляет HTTP-запросы к серверу через REST API с JWT-токеном в заголовке.
- Сервер проверяет токен, определяет пользователя и права доступа.
- Запрос передается в соответствующий модуль (например, аутентификация, управление проектами или файлами).
- Сервер взаимодействует с PostgreSQL (для данных) и/или MinIO (для файлов).
- Формируется ответ и возвращается клиенту.

Структура серверной части (модули):
- Интеграция с БД: Взаимодействие с PostgreSQL для структурированных данных.
- Интеграция с хранилищем: Взаимодействие с MinIO для загрузки и получения файлов.
- Вспомогательные модули.
Остальные модули подробно обсуждаются в последующих разделах.
=== Модуль аутентификации и авторизации

Модуль обеспечивает полный цикл управления доступом. Основные функции включают:
- регистрацию и аутентификацию пользователей;
- генерацию и валидацию JWT токенов;
- контроль доступа на основе ролей;
- защиту эндпоинтов с проверкой прав доступа.

Реализация использует следующие технологии и библиотеки:
- FastAPI с зависимостями для инъекции текущего пользователя;
- PyJWT для создания и верификации JWT токенов;
- python-jose с алгоритмом HS256 для подписи токенов;
- bcrypt для хеширования паролей с солью;
- Pydantic для валидации данных аутентификации.

=== Модуль управления пользователями

Данный модуль отвечает за работу с учетными записями пользователей. Функциональность включает:
- полный CRUD для пользователей;
- управление ролями и профилями пользователей;
- связи пользователей с проектами через модель TeamMember;
- пагинацию и фильтрацию списка пользователей.

Реализация основана на следующих технологиях:
- SQLAlchemy ORM для объектно-реляционного отображения;
- Alembic для миграций базы данных;
- Pydantic схемах для сериализации и валидации;
- FastAPI эндпоинтах с автоматической документацией.

=== Модуль управления проектами

Модуль предоставляет комплексное управление проектной деятельностью. Ключевые возможности:
- CRUD операции для проектов, предметных областей, связей между проектами;
- расширенный поиск и фильтрацию по названию, описанию, ключевым словам;
- систему тегов с JSONB хранением в PostgreSQL;
- иерархическую систему прав доступа к проектам.

Для реализации используются следующие технологии:
- SQLAlchemy с поддержкой JSONB для тегов;
- PostgreSQL полнотекстовый поиск и индексы;
- Pydantic с кастомными валидаторами для сложных структур;
- FastAPI Query parameters для фильтрации.

=== Модуль работы с файлами

Организует работу с файловыми ресурсами проектов. Основные функции:
- загрузку файлов в объектное хранилище MinIO;
- хранение метаданных файлов в PostgreSQL;
- скачивание файлов с контролем доступа;
- обновление и удаление файлов;
- проверку квот размера проекта.

Реализация построена на следующих компонентах:
- MinIO Python SDK для взаимодействия с объектным хранилищем;
- SQLAlchemy для хранения метаданных файлов;
- FastAPI UploadFile для обработки загрузок;
- StreamingResponse для эффективной отдачи файлов.


=== Архитектура хранилища
- Реляционная БД PostgreSQL: Хранит структурированную информацию (пользователи, проекты, метаданные).
- Объектное хранилище MinIO: Хранит файлы; принцип — загрузка через сервер, запись URL в БД, выдача pre-signed URL для доступа.

=== Структура кода клиентского приложения:
- Страницы представляют собой компоненты Vue 3.
- Переходы между страницами реализованы с помощью vue router, включая перенаправление на страницу входа для неавторизованных пользователей.
- Связи между страницами — через ссылки router link.

==  Интерфейс пользователя

Список страниц: домашняя, страница проекта, страница настроек проекта, страница профиля пользователя, страница создания проекта, страница входа.

Был разработан интерфейс для загрузки, поиска и фильтрации проектов; удобный и интуитивно понятный веб-интерфейс. Реализованы функции поиска, фильтрации; поддержка просмотра файлов прямо на платформе (для таблиц, кодов, документов; другие файлы скачиваются).

==  Логика работы основных функций
Для пользователя:
- Регистрация и авторизация в системе (через корпоративную почту ТюмГУ).
- Загрузка файлов проекта.
- Поиск и фильтрация проектов по метаданным (название, теги, дата создания, описание, предметная область).
- Просмотр своих загруженных работ и их метаданных.
- Настройка параметров проекта: изменение названия, описания, тегов, предметной области.
- Настройка участников проекта (приглашение, назначение ролей).
- Параметры файлов; ссылка на проект (для ссылок на другие работы).
- Создание и настройка проекта (публичный/приватный; видимость файлов и участников).
- Хранение любых типов файлов (просмотр таблиц на платформе; скачивание остальных).
- Выход из проекта.

Для куратора:
- Поиск и фильтрация проектов студентов.
- Редактирование метаданных проектов (название, автор, теги, описание).
- Управление правами доступа к проектам.

Общая логика ключевых функций:
- Загрузка файлов: Клиент отправляет файл на сервер; сервер сохраняет в MinIO, получает URL; записывает метаданные в PostgreSQL.
- Поиск и фильтрация: По полям (название, описание, теги, предметная область); автоматическая загрузка данных из систем вуза.
- Просмотр/скачивание: Клиент запрашивает URL через сервер; сервер проверяет права и выдает pre-signed URL или проксирует файл.
- Безопасность: Защита от несанкционированного доступа (шифрование, управление правами); контроль формата и размера файлов (макс. 1 ГБ; форматы: txt, PDF (текст/сканы), Word, Excel, JSON).
- Поток обработки запроса: Клиент отправляет запрос с JWT; сервер проверяет токен и права; передает в модуль; взаимодействует с БД/MinIO; возвращает ответ.

== Примеры фрагментов кода (по необходимости)
=== Модель пользователя

#figure(
  ```python
  class User(Base):
      __tablename__ = "users"
      
      id: int = Column(Integer, primary_key=True, index=True)
      email: str = Column(String, unique=True, index=True)
      hashed_password: str = Column(String)
      full_name: str = Column(String)
      role: str = Column(String)
      created_at: datetime = Column(DateTime, default=datetime.utcnow)
  ```,
  caption: [Модель пользователя в SQLAlchemy],
) <user-model>

=== CRUD операции

#figure(
  ```python
  def create_user(db: Session, user: UserCreate):
      hashed_password = bcrypt.hash(user.password)
      db_user = User(
          email=user.email,
          hashed_password=hashed_password,
          full_name=user.full_name,
          role=user.role
      )
      db.add(db_user)
      db.commit()
      db.refresh(db_user)
      return db_user
  ```,
  caption: [Функция создания пользователя],
) <create-user-function>

=== API эндпоинт

#figure(
  ```python
  @router.get("/projects/", response_model=List[ProjectRead])
  def read_projects(
      skip: int = 0,
      limit: int = 100,
      current_user: User = Depends(get_current_user),
      db: Session = Depends(get_db)
  ):
      query = db.query(Project)

      if current_user.role != "админ":
          # Пользователь - не админ, фильтруем только публичные проекты или проекты, в которых он есть
          subquery = db.query(TeamMember.project_id).filter(TeamMember.user_id == current_user.id).subquery()

          query = query.filter(
              (Project.is_public == True) |
              (Project.id.in_(subquery))
          )

      projects = query.offset(skip).limit(limit).all()
      return projects
  ```,
  caption: [Эндпоинт для получения списка проектов с фильтрацией по правам доступа],
) <api-endpoint>

=== Работа с файлами

#figure(
  ```python
  def upload_file(file_data, file_name, content_type):
      client = Minio(
          "minio:9000",
          access_key=MINIO_ACCESS_KEY,
          secret_key=MINIO_SECRET_KEY,
          secure=False
      )
      
      client.put_object(
          "projects",
          file_name,
          file_data,
          length=len(file_data),
          content_type=content_type
      )
      
      return f"http://minio/projects/{file_name}"
  ```,
  caption: [Функция загрузки файла в MinIO],
) <file-upload>

=== Pydantic схемы

#figure(
  ```python
  class UserCreate(BaseModel):
      email: str = Field(..., regex=r"^[^@\s]+@[^@\s]+\.[^@\s]+$")
      password: str = Field(..., min_length=6)
      full_name: str = Field(..., min_length=1)
      role: str = Field(..., pattern="^(админ|участник)$")

  class UserRead(BaseModel):
      id: int
      email: str
      full_name: str
      role: str
      created_at: datetime
  ```,
  caption: [Pydantic схемы для валидации данных],
) <pydantic-schemas>

=== Аутентификация

#figure(
  ```python
  def create_access_token(data: dict):
      to_encode = data.copy()
      expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
      to_encode.update({"exp": expire})
      encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
      return encoded_jwt
  ```,
  caption: [Генерация JWT токена],
) <jwt-token>

== Преодоленные сложности и принятые технические решения
- Выбор PostgreSQL и MinIO для удобного развертывания (Docker-образы) решает проблему развертывания на незнакомой инфраструктуре.
- Использование FastAPI для простоты и минимальных зависимостей упрощает разработку.
- JWT для авторизации без SSO решает вопрос безопасности.
- Нормализация БД (3НФ) минимизирует избыточность и повышает целостность.